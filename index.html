<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolving Societies</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #ffffff;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 11px;
            max-width: 320px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .society {
            margin: 10px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
        .society-name {
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 5px;
        }
        .stat {
            margin: 3px 0;
            font-size: 10px;
        }
        .timer {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
        }
        .time-display {
            font-size: 24px;
            font-weight: bold;
        }
        .gen-display {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 5px;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
        }
        .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            margin: 2px;
            font-weight: bold;
        }
        button {
            background: #4a9eff;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            margin: 3px;
            font-size: 11px;
        }
        button:hover {
            background: #6ab4ff;
        }
        .entity-info {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 11px;
            pointer-events: none;
            display: none;
            max-width: 280px;
        }
        .trait-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin: 3px 0;
            overflow: hidden;
        }
        .trait-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a9eff, #00ff88);
            border-radius: 4px;
        }
        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 4px 0;
        }
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 6px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="timer">
        <div class="time-display" id="timer">0:00</div>
        <div class="gen-display" id="generation">Generation: 1 | Population: 0</div>
    </div>
    
    <div class="info" id="stats"></div>
    
    <div class="entity-info" id="entityInfo"></div>
    
    <div class="legend">
        <div style="font-weight: bold; margin-bottom: 5px;">RESOURCES</div>
        <div class="legend-item"><div class="legend-dot" style="background: #ff6b6b;"></div>Meat (Triangles)</div>
        <div class="legend-item"><div class="legend-dot" style="background: #4ecdc4;"></div>Plants (Circles)</div>
        <div class="legend-item"><div class="legend-dot" style="background: #95e1d3;"></div>Minerals (Squares)</div>
        <div class="legend-item"><div class="legend-dot" style="background: #ffeb3b;"></div>Universal</div>
    </div>
    
    <div class="controls">
        <div><span class="key">WASD</span> Move | <span class="key">Wheel</span> Zoom | <span class="key">Space</span> Pause</div>
        <div><span class="key">Click</span> entity for info</div>
        <button id="restart">Restart</button>
        <button id="speedUp">Speed: 1x</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Game state
        let simulationTime = 0;
        let isPaused = false;
        let lastTime = Date.now();
        let timeSpeed = 1;
        let maxGeneration = 1;
        let entityIdCounter = 0;
        
        // Camera
        let camera = { x: 0, y: 0, zoom: 0.6 };
        
        // Communication signals
        const signals = [];
        
        class Signal {
            constructor(x, y, type, message) {
                this.x = x;
                this.y = y;
                this.type = type; // 'alert', 'food', 'help', 'mate'
                this.message = message;
                this.radius = 0;
                this.maxRadius = 150;
                this.lifetime = 2;
                this.age = 0;
            }
            
            update(dt) {
                this.age += dt;
                this.radius = (this.age / this.lifetime) * this.maxRadius;
                return this.age < this.lifetime;
            }
            
            draw(ctx, camera) {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                const alpha = 1 - (this.age / this.lifetime);
                
                const colors = {
                    'alert': '#ff0000',
                    'food': '#00ff00',
                    'help': '#ffff00',
                    'mate': '#ff00ff'
                };
                
                ctx.strokeStyle = colors[this.type] + Math.floor(alpha * 100).toString(16).padStart(2, '0');
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.radius * camera.zoom, 0, Math.PI * 2);
                ctx.stroke();
                
                if (alpha > 0.5) {
                    ctx.fillStyle = colors[this.type];
                    ctx.font = `${10 * camera.zoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(this.message, screenX, screenY - this.radius * camera.zoom - 5);
                }
            }
        }
        
        // Resources with types
        class Resource {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'meat', 'plant', 'mineral', 'universal'
                this.amount = 100;
                this.respawnTime = 0;
            }
            
            draw(ctx, camera) {
                if (this.amount <= 0) return;
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                const size = 6 * camera.zoom * (this.amount / 100);
                
                const colors = {
                    'meat': '#ff6b6b',
                    'plant': '#4ecdc4',
                    'mineral': '#95e1d3',
                    'universal': '#ffeb3b'
                };
                
                ctx.fillStyle = colors[this.type];
                ctx.beginPath();
                ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            distanceTo(entity) {
                const dx = this.x - entity.x;
                const dy = this.y - entity.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }
        
        const resources = [];
        
        // Neural Network
        class NeuralNetwork {
            constructor(parent1Genes, parent2Genes) {
                if (parent1Genes && parent2Genes) {
                    this.genes = {
                        aggression: this.inherit(parent1Genes.aggression, parent2Genes.aggression),
                        cooperation: this.inherit(parent1Genes.cooperation, parent2Genes.cooperation),
                        resourceGathering: this.inherit(parent1Genes.resourceGathering, parent2Genes.resourceGathering),
                        reproductionDrive: this.inherit(parent1Genes.reproductionDrive, parent2Genes.reproductionDrive),
                        speed: this.inherit(parent1Genes.speed, parent2Genes.speed),
                        efficiency: this.inherit(parent1Genes.efficiency, parent2Genes.efficiency),
                        socialDistance: this.inherit(parent1Genes.socialDistance, parent2Genes.socialDistance),
                        communication: this.inherit(parent1Genes.communication, parent2Genes.communication),
                        adaptability: this.inherit(parent1Genes.adaptability, parent2Genes.adaptability)
                    };
                } else {
                    this.genes = {
                        aggression: Math.random(),
                        cooperation: Math.random(),
                        resourceGathering: Math.random(),
                        reproductionDrive: Math.random(),
                        speed: Math.random(),
                        efficiency: Math.random(),
                        socialDistance: Math.random(),
                        communication: Math.random(),
                        adaptability: Math.random()
                    };
                }
            }
            
            inherit(gene1, gene2) {
                const avg = (gene1 + gene2) / 2;
                const mutation = (Math.random() - 0.5) * 0.15;
                return Math.max(0, Math.min(1, avg + mutation));
            }
        }
        
        // Entity
        class Entity {
            constructor(x, y, society, parent1 = null, parent2 = null, generation = 1) {
                this.id = entityIdCounter++;
                this.x = x;
                this.y = y;
                this.society = society;
                this.vx = 0;
                this.vy = 0;
                this.energy = 100;
                this.age = 0;
                this.generation = generation;
                this.parent1 = parent1;
                this.parent2 = parent2;
                this.children = [];
                this.reproductionCooldown = 0;
                this.communicationCooldown = 0;
                this.lastMeal = null;
                this.dietBonus = 0;
                
                if (parent1 && parent2) {
                    this.brain = new NeuralNetwork(parent1.brain.genes, parent2.brain.genes);
                    this.isHybrid = parent1.society !== parent2.society;
                } else {
                    this.brain = new NeuralNetwork();
                    this.isHybrid = false;
                }
                
                if (parent1) parent1.children.push(this);
                if (parent2 && parent2 !== parent1) parent2.children.push(this);
            }
            
            update(deltaTime, entities, resources, signals) {
                this.age += deltaTime;
                
                // Energy drain based on efficiency and environment
                const envPenalty = this.society.environment.harshness;
                const energyDrain = (0.2 + envPenalty * 0.1) * (1 - this.brain.genes.efficiency * 0.4);
                this.energy -= deltaTime * energyDrain;
                
                // Diet bonus decay
                this.dietBonus *= 0.99;
                
                this.reproductionCooldown = Math.max(0, this.reproductionCooldown - deltaTime);
                this.communicationCooldown = Math.max(0, this.communicationCooldown - deltaTime);
                
                if (this.energy <= 0) {
                    return false;
                }
                
                this.energy = Math.min(150, this.energy);
                
                // Listen to signals
                this.processSignals(signals);
                
                // AI behavior
                this.behaviorAI(entities, resources, signals);
                
                // Move with speed influenced by diet
                const speedBonus = 1 + this.dietBonus * 0.3;
                const speed = 10 * (0.5 + this.brain.genes.speed * 0.5) * speedBonus;
                this.x += this.vx * deltaTime * speed;
                this.y += this.vy * deltaTime * speed;
                
                this.vx *= 0.95;
                this.vy *= 0.95;
                
                // Stay in or near territory
                const territory = this.society.territory;
                const margin = 100;
                if (this.x < territory.x - margin) this.vx += 0.5;
                if (this.x > territory.x + territory.width + margin) this.vx -= 0.5;
                if (this.y < territory.y - margin) this.vy += 0.5;
                if (this.y > territory.y + territory.height + margin) this.vy -= 0.5;
                
                return true;
            }
            
            processSignals(signals) {
                for (let signal of signals) {
                    const dist = Math.sqrt((this.x - signal.x) ** 2 + (this.y - signal.y) ** 2);
                    if (dist < signal.radius) {
                        // React to signal based on communication gene
                        if (Math.random() < this.brain.genes.communication) {
                            this.reactToSignal(signal);
                        }
                    }
                }
            }
            
            reactToSignal(signal) {
                switch(signal.type) {
                    case 'food':
                        if (this.energy < 70) {
                            this.moveTo(signal.x, signal.y, 1.2);
                        }
                        break;
                    case 'alert':
                        const dx = this.x - signal.x;
                        const dy = this.y - signal.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0) {
                            this.vx += (dx / dist) * 0.5;
                            this.vy += (dy / dist) * 0.5;
                        }
                        break;
                    case 'help':
                        if (this.brain.genes.cooperation > 0.5) {
                            this.moveTo(signal.x, signal.y, 1.0);
                        }
                        break;
                }
            }
            
            communicate(type, message, signals) {
                if (this.communicationCooldown > 0) return;
                if (this.brain.genes.communication < 0.3) return;
                
                signals.push(new Signal(this.x, this.y, type, message));
                this.communicationCooldown = 5;
            }
            
            behaviorAI(entities, resources, signals) {
                const nearbyFood = resources.filter(r => {
                    if (r.amount <= 0) return false;
                    const dist = this.distanceTo(r);
                    const canEat = this.canEatResource(r);
                    return dist < 250 && canEat;
                }).length;
                
                const nearbyAllies = entities.filter(e => 
                    e.society === this.society && this.distanceTo(e) < 150
                ).length;
                
                const nearbyEnemies = entities.filter(e => 
                    e.society !== this.society && this.distanceTo(e) < 150
                ).length;
                
                // Priority system
                if (this.energy < 40) {
                    this.gatherResources(resources, signals);
                } else if (nearbyEnemies > 0 && this.brain.genes.aggression > 0.4) {
                    this.fight(entities, signals);
                } else if (this.energy > 80 && this.reproductionCooldown === 0) {
                    this.seekMate(entities);
                } else if (nearbyFood > 0 && this.energy < 90) {
                    this.gatherResources(resources, signals);
                } else if (this.brain.genes.cooperation > 0.5) {
                    this.socialize(entities);
                } else {
                    this.wander();
                }
            }
            
            canEatResource(resource) {
                // Check if this entity can eat this resource type
                const preferredFood = this.society.preferredFood;
                if (resource.type === 'universal') return true;
                if (preferredFood.includes(resource.type)) return true;
                
                // Hybrids and adaptable entities can eat more
                if (this.isHybrid || this.brain.genes.adaptability > 0.7) {
                    return Math.random() < 0.5;
                }
                
                return false;
            }
            
            getResourceValue(resource) {
                const preferredFood = this.society.preferredFood;
                let value = 15;
                
                if (resource.type === 'universal') {
                    value = 20;
                } else if (preferredFood.includes(resource.type)) {
                    value = 25; // Preferred food gives more energy
                    
                    // Diet-specific bonuses
                    if (resource.type === 'meat') {
                        this.dietBonus = 0.3; // Speed boost
                    } else if (resource.type === 'plant') {
                        this.energy += 5; // Extra healing
                    } else if (resource.type === 'mineral') {
                        this.brain.genes.efficiency = Math.min(1, this.brain.genes.efficiency + 0.01); // Permanent efficiency
                    }
                }
                
                this.lastMeal = resource.type;
                return value;
            }
            
            gatherResources(resources, signals) {
                const available = resources.filter(r => 
                    r.amount > 0 && this.canEatResource(r)
                ).sort((a, b) => this.distanceTo(a) - this.distanceTo(b));
                
                if (available.length === 0) {
                    if (this.energy < 30) {
                        this.communicate('help', '!', signals);
                    }
                    return;
                }
                
                const nearest = available[0];
                this.moveTo(nearest.x, nearest.y, 1.2);
                
                if (this.distanceTo(nearest) < 15) {
                    const value = this.getResourceValue(nearest);
                    const taken = Math.min(value, nearest.amount);
                    nearest.amount -= taken;
                    this.energy += taken;
                    
                    // Communicate food location to others
                    if (available.length > 1 && Math.random() < this.brain.genes.communication) {
                        this.communicate('food', 'ðŸƒ', signals);
                    }
                }
            }
            
            fight(entities, signals) {
                const enemies = entities.filter(e => 
                    e.society !== this.society && this.distanceTo(e) < 150
                );
                
                if (enemies.length > 0) {
                    const target = enemies[0];
                    this.moveTo(target.x, target.y, 1.3);
                    
                    if (this.distanceTo(target) < 20) {
                        const damage = 0.4 * this.brain.genes.aggression;
                        target.energy -= damage;
                        this.energy -= 0.15;
                        
                        // Alert allies
                        if (Math.random() < 0.3) {
                            this.communicate('alert', 'âš ', signals);
                        }
                    }
                }
            }
            
            seekMate(entities) {
                if (this.energy < 70 || this.reproductionCooldown > 0) return;
                
                const range = 180 * (1 + this.brain.genes.socialDistance);
                const mates = entities.filter(e => 
                    e !== this && 
                    e.energy > 70 && 
                    e.reproductionCooldown === 0 &&
                    this.distanceTo(e) < range
                );
                
                if (mates.length > 0) {
                    const mate = mates[0];
                    this.moveTo(mate.x, mate.y, 0.9);
                    
                    if (this.distanceTo(mate) < 25 && Math.random() < 0.1) {
                        this.communicate('mate', 'â¤', signals);
                    }
                }
            }
            
            socialize(entities) {
                const allies = entities.filter(e => 
                    e.society === this.society && 
                    e !== this && 
                    this.distanceTo(e) < 200
                );
                
                if (allies.length > 0) {
                    const target = allies[Math.floor(Math.random() * allies.length)];
                    const targetDist = 60 * this.brain.genes.socialDistance;
                    const currentDist = this.distanceTo(target);
                    
                    if (currentDist > targetDist + 20) {
                        this.moveTo(target.x, target.y, 0.6);
                    } else if (currentDist < targetDist - 20) {
                        const dx = this.x - target.x;
                        const dy = this.y - target.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0) {
                            this.vx += (dx / dist) * 0.3;
                            this.vy += (dy / dist) * 0.3;
                        }
                    }
                }
            }
            
            wander() {
                if (Math.random() < 0.03) {
                    this.vx = (Math.random() - 0.5) * 0.6;
                    this.vy = (Math.random() - 0.5) * 0.6;
                }
            }
            
            draw(ctx, camera) {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                const size = 9 * camera.zoom;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                
                if (this.isHybrid) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffff00';
                }
                
                this.society.drawShape(ctx, size, this.energy / 100);
                ctx.shadowBlur = 0;
                
                if (this.generation > 1) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.font = `${7 * camera.zoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(`G${this.generation}`, 0, size + 10);
                }
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(-size, -size - 6, size * 2, 3);
                ctx.fillStyle = this.energy > 50 ? '#00ff00' : this.energy > 25 ? '#ffff00' : '#ff0000';
                ctx.fillRect(-size, -size - 6, size * 2 * (Math.min(this.energy, 100) / 100), 3);
                
                ctx.restore();
            }
            
            distanceTo(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            moveTo(x, y, speed) {
                const dx = x - this.x;
                const dy = y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    this.vx = (dx / dist) * speed;
                    this.vy = (dy / dist) * speed;
                }
            }
        }
        
        // Societies with unique environments
        const societies = {
            triangles: {
                name: 'Triangles',
                color: '#ff4444',
                territory: { x: -600, y: -400, width: 500, height: 400 },
                environment: {
                    name: 'Volcanic Wasteland',
                    harshness: 0.5,
                    description: 'Hot, aggressive, resource-scarce'
                },
                preferredFood: ['meat', 'universal'],
                culture: 'Warrior hunters who thrive on conflict',
                drawShape: (ctx, size, health) => {
                    ctx.fillStyle = `rgba(255, 68, 68, ${health * 0.7 + 0.3})`;
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(-size, size);
                    ctx.lineTo(size, size);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            },
            circles: {
                name: 'Circles',
                color: '#4444ff',
                territory: { x: 100, y: -400, width: 500, height: 400 },
                environment: {
                    name: 'Lush Gardens',
                    harshness: 0.1,
                    description: 'Peaceful, abundant vegetation'
                },
                preferredFood: ['plant', 'universal'],
                culture: 'Peaceful gatherers living in harmony',
                drawShape: (ctx, size, health) => {
                    ctx.fillStyle = `rgba(68, 68, 255, ${health * 0.7 + 0.3})`;
                    ctx.strokeStyle = '#0000ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
            },
            squares: {
                name: 'Squares',
                color: '#44ff44',
                territory: { x: -250, y: 50, width: 500, height: 400 },
                environment: {
                    name: 'Crystal Caverns',
                    harshness: 0.3,
                    description: 'Rich in minerals, stable climate'
                },
                preferredFood: ['mineral', 'universal'],
                culture: 'Methodical builders focused on efficiency',
                drawShape: (ctx, size, health) => {
                    ctx.fillStyle = `rgba(68, 255, 68, ${health * 0.7 + 0.3})`;
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.fillRect(-size, -size, size * 2, size * 2);
                    ctx.strokeRect(-size, -size, size * 2, size * 2);
                }
            }
        };
        
        let entities = [];
        let selectedEntity = null;
        
        function initWorld() {
            entities = [];
            resources.length = 0;
            signals.length = 0;
            simulationTime = 0;
            maxGeneration = 1;
            entityIdCounter = 0;
            selectedEntity = null;
            
            // Create initial populations
            for (let society of Object.values(societies)) {
                for (let i = 0; i < 25; i++) {
                    const x = society.territory.x + Math.random() * society.territory.width;
                    const y = society.territory.y + Math.random() * society.territory.height;
                    entities.push(new Entity(x, y, society));
                }
            }
            
            // Spawn resources based on territories
            for (let society of Object.values(societies)) {
                const t = society.territory;
                const foodType = society.preferredFood[0];
                
                // Spawn preferred food in their territory
                for (let i = 0; i < 30; i++) {
                    resources.push(new Resource(
                        t.x + Math.random() * t.width,
                        t.y + Math.random() * t.height,
                        foodType
                    ));
                }
                
                // Spawn some universal food
                for (let i = 0; i < 10; i++) {
                    resources.push(new Resource(
                        t.x + Math.random() * t.width,
                        t.y + Math.random() * t.height,
                        'universal'
                    ));
                }
            }
            
            // Add random resources
            for (let i = 0; i < 50; i++) {
                const types = ['meat', 'plant', 'mineral', 'universal'];
                resources.push(new Resource(
                    Math.random() * 1600 - 800,
                    Math.random() * 1200 - 600,
                    types[Math.floor(Math.random() * types.length)]
                ));
            }
        }
        
        function reproduce(parent1, parent2) {
            if (parent1.reproductionCooldown > 0 || parent2.reproductionCooldown > 0) return;
            if (parent1.energy < 70 || parent2.energy < 70) return;
            
            parent1.energy -= 30;
            parent2.energy -= 30;
            parent1.reproductionCooldown = 12;
            parent2.reproductionCooldown = 12;
            
            const x = (parent1.x + parent2.x) / 2;
            const y = (parent1.y + parent2.y) / 2;
            
            let childSociety;
            if (parent1.society === parent2.society) {
                childSociety = parent1.society;
            } else {
                childSociety = Math.random() < 0.5 ? parent1.society : parent2.society;
            }
            
            const generation = Math.max(parent1.generation, parent2.generation) + 1;
            maxGeneration = Math.max(maxGeneration, generation);
            
            const child = new Entity(
                x + (Math.random() - 0.5) * 40, 
                y + (Math.random() - 0.5) * 40, 
                childSociety,
                parent1,
                parent2,
                generation
            );
            child.energy = 80;
            entities.push(child);
        }
        
        // Mouse interaction
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const worldX = (mouseX - canvas.width / 2) / camera.zoom + camera.x;
            const worldY = (mouseY - canvas.height / 2) / camera.zoom + camera.y;
            
            selectedEntity = null;
            let minDist = 20 / camera.zoom;
            
            for (let entity of entities) {
                const dist = Math.sqrt((entity.x - worldX) ** 2 + (entity.y - worldY) ** 2);
                if (dist < minDist) {
                    selectedEntity = entity;
                    minDist = dist;
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (selectedEntity) {
                const rect = canvas.getBoundingClientRect();
                const infoDiv = document.getElementById('entityInfo');
                infoDiv.style.left = (e.clientX + 15) + 'px';
                infoDiv.style.top = (e.clientY + 15) + 'px';
                infoDiv.style.display = 'block';
                
                const genes = selectedEntity.brain.genes;
                let html = `
                    <div style="color: ${selectedEntity.society.color}; font-weight: bold; margin-bottom: 8px;">
                        ${selectedEntity.society.name} #${selectedEntity.id}
                    </div>
                    <div style="font-size: 10px; margin-bottom: 5px;">
                        Gen: ${selectedEntity.generation} | Age: ${selectedEntity.age.toFixed(1)}s<br>
                        Energy: ${selectedEntity.energy.toFixed(1)} | Children: ${selectedEntity.children.length}
                        ${selectedEntity.isHybrid ? '<br><span style="color: #ffff00;">âš¡ HYBRID</span>' : ''}
                        ${selectedEntity.lastMeal ? `<br>Last meal: ${selectedEntity.lastMeal}` : ''}
                    </div>
                    <div style="font-size: 9px; margin-top: 8px;">
                        <b>Genetic Traits:</b><br>
                `;
                
                for (let [trait, value] of Object.entries(genes)) {
                    const percent = (value * 100).toFixed(0);
                    html += `
                        ${trait}: ${percent}%
                        <div class="trait-bar">
                            <div class="trait-fill" style="width: ${percent}%"></div>
                        </div>
                    `;
                }
                
                if (selectedEntity.parent1) {
                    html += `<br><b>Parents:</b> #${selectedEntity.parent1.id}`;
                    if (selectedEntity.parent2) {
                        html += ` & #${selectedEntity.parent2.id}`;
                    }
                }
                
                html += `</div>`;
                infoDiv.innerHTML = html;
            } else {
                document.getElementById('entityInfo').style.display = 'none';
            }
        });
        
        // Controls
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ') {
                e.preventDefault();
                isPaused = !isPaused;
            }
        });
        window.addEventListener('keyup', (e) => keys[e.key] = false);
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.zoom = Math.max(0.3, Math.min(2.5, camera.zoom + (e.deltaY < 0 ? 0.1 : -0.1)));
        });
        
        document.getElementById('restart').addEventListener('click', initWorld);
        
        let speedLevel = 0;
        const speeds = [1, 2, 5, 10];
        document.getElementById('speedUp').addEventListener('click', function() {
            speedLevel = (speedLevel + 1) % speeds.length;
            timeSpeed = speeds[speedLevel];
            this.textContent = `Speed: ${timeSpeed}x`;
        });
        
        function updateCamera() {
            const speed = 8 / camera.zoom;
            if (keys['w'] || keys['ArrowUp']) camera.y -= speed;
            if (keys['s'] || keys['ArrowDown']) camera.y += speed;
            if (keys['a'] || keys['ArrowLeft']) camera.x -= speed;
            if (keys['d'] || keys['ArrowRight']) camera.x += speed;
        }
        
        function update() {
            const now = Date.now();
            let deltaTime = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;
            
            if (!isPaused) {
                deltaTime *= timeSpeed;
                simulationTime += deltaTime;
                
                // Update signals
                const activeSignals = [];
                for (let signal of signals) {
                    if (signal.update(deltaTime)) {
                        activeSignals.push(signal);
                    }
                }
                signals.length = 0;
                signals.push(...activeSignals);
                
                // Update entities
                const newEntities = [];
                for (let entity of entities) {
                    if (entity.update(deltaTime, entities, resources, signals)) {
                        newEntities.push(entity);
                    }
                }
                entities = newEntities;
                
                // Reproduction
                const checkedPairs = new Set();
                for (let i = 0; i < entities.length; i++) {
                    for (let j = i + 1; j < entities.length; j++) {
                        const e1 = entities[i];
                        const e2 = entities[j];
                        const pairKey = `${Math.min(e1.id, e2.id)}-${Math.max(e1.id, e2.id)}`;
                        
                        if (!checkedPairs.has(pairKey) && 
                            e1.distanceTo(e2) < 30 &&
                            e1.energy > 70 && e2.energy > 70 &&
                            e1.reproductionCooldown === 0 && e2.reproductionCooldown === 0) {
                            reproduce(e1, e2);
                            checkedPairs.add(pairKey);
                        }
                    }
                }
                
                // Respawn resources in territories
                for (let society of Object.values(societies)) {
                    const t = society.territory;
                    const foodInTerritory = resources.filter(r => 
                        r.x >= t.x && r.x <= t.x + t.width &&
                        r.y >= t.y && r.y <= t.y + t.height &&
                        r.amount > 0
                    ).length;
                    
                    if (foodInTerritory < 20 && Math.random() < 0.2 * timeSpeed) {
                        const foodType = Math.random() < 0.7 ? society.preferredFood[0] : 'universal';
                        resources.push(new Resource(
                            t.x + Math.random() * t.width,
                            t.y + Math.random() * t.height,
                            foodType
                        ));
                    }
                }
            }
        }
        
        function draw() {
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);
            
            // Draw territories with environment effects
            for (let society of Object.values(societies)) {
                const t = society.territory;
                
                // Environment background
                const envColors = {
                    'Volcanic Wasteland': 'rgba(255, 100, 50, 0.08)',
                    'Lush Gardens': 'rgba(100, 255, 150, 0.08)',
                    'Crystal Caverns': 'rgba(150, 255, 200, 0.08)'
                };
                
                ctx.fillStyle = envColors[society.environment.name];
                ctx.fillRect(t.x, t.y, t.width, t.height);
                
                ctx.strokeStyle = society.color + '40';
                ctx.lineWidth = 3 / camera.zoom;
                ctx.strokeRect(t.x, t.y, t.width, t.height);
                
                // Territory label
                ctx.fillStyle = society.color;
                ctx.font = `bold ${20 / camera.zoom}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(society.name, t.x + t.width / 2, t.y - 20 / camera.zoom);
                
                // Environment info
                ctx.font = `${12 / camera.zoom}px Arial`;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillText(society.environment.name, t.x + t.width / 2, t.y - 5 / camera.zoom);
            }
            
            // Draw resources
            for (let resource of resources) {
                resource.draw(ctx, camera);
            }
            
            // Draw communication signals
            for (let signal of signals) {
                signal.draw(ctx, camera);
            }
            
            // Draw entities
            for (let entity of entities) {
                entity.draw(ctx, camera);
                
                if (entity === selectedEntity) {
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3 / camera.zoom;
                    ctx.beginPath();
                    ctx.arc(entity.x, entity.y, 18 / camera.zoom, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            ctx.restore();
            
            // Update UI
            const minutes = Math.floor(simulationTime / 60);
            const seconds = Math.floor(simulationTime % 60);
            document.getElementById('timer').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('generation').textContent = 
                `Max Generation: ${maxGeneration} | Total: ${entities.length}`;
            
            // Stats
            let statsHTML = '<div style="font-size: 13px; font-weight: bold; margin-bottom: 10px;">SOCIETIES</div>';
            for (let society of Object.values(societies)) {
                const pop = entities.filter(e => e.society === society);
                const hybrids = pop.filter(e => e.isHybrid).length;
                const avgGen = pop.length > 0 ? (pop.reduce((sum, e) => sum + e.generation, 0) / pop.length).toFixed(1) : 0;
                const avgEnergy = pop.length > 0 ? (pop.reduce((sum, e) => sum + e.energy, 0) / pop.length).toFixed(1) : 0;
                const children = pop.reduce((sum, e) => sum + e.children.length, 0);
                
                statsHTML += `
                    <div class="society">
                        <div class="society-name" style="color: ${society.color}">${society.name}</div>
                        <div class="stat">Pop: ${pop.length} (${hybrids} hybrids)</div>
                        <div class="stat">Avg Gen: ${avgGen} | Avg Energy: ${avgEnergy}</div>
                        <div class="stat">Children: ${children}</div>
                        <div class="stat" style="font-size: 9px; opacity: 0.7; margin-top: 3px;">
                            ${society.environment.name}<br>
                            Diet: ${society.preferredFood.join(', ')}
                        </div>
                    </div>
                `;
            }
            document.getElementById('stats').innerHTML = statsHTML;
        }
        
        function gameLoop() {
            updateCamera();
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        initWorld();
        gameLoop();
    </script>
</body>
</html>